<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Siri Organic Icon - Randomized</title>
    <style>
        :root {
            --siri-size: 64px;
        }

        body {
            margin: 0;
            background-color: #0d0d0d;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .screen-preview {
            width: 300px;
            height: 150px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%);
            border-radius: 20px;
        }

        .siri-wrapper {
            width: var(--siri-size);
            height: var(--siri-size);
            border: 1.5px solid rgba(255, 255, 255, 0.12);
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(70, 130, 255, 0.15);
            backdrop-filter: blur(2px);
        }

        #siriCanvas {
            width: 100%;
            height: 100%;
            mix-blend-mode: screen;
        }
    </style>
</head>

<body>

    <div class="screen-preview">
        <div class="siri-wrapper">
            <canvas id="siriCanvas"></canvas>
        </div>
    </div>

    <script type="x-shader/x-fragment" id="fragmentShader">
    precision highp float;
    uniform float iTime;
    uniform vec2 iResolution;
    
    // 接收来自 JS 的随机参数
    uniform float uRotDir;      // 旋转方向 (1.0 或 -1.0)
    uniform float uRotSpeed;    // 旋转基础速度
    uniform float uFlowSpeed;   // 流动基础速度
    uniform float uBreatheFreq; // 呼吸频率
    uniform vec2 uRandomSeed;   // 随机种子偏移

    mat2 rot(float a) {
        float s = sin(a); float c = cos(a);
        return mat2(c, -s, s, c);
    }

    void main() {
        vec2 p = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.y, iResolution.x);
        
        // --- 1. 非线性 + 随机方向旋转 ---
        // 叠加两个不同频率的 sin 波，制造出忽快忽慢、甚至短暂停顿的效果
        float nonlinearRot = iTime * uRotSpeed * uRotDir 
                           + sin(iTime * 1.5) * 0.5 
                           + cos(iTime * 0.7) * 0.3;
        p *= rot(nonlinearRot); 

        // --- 2. 随机呼吸缩放 ---
        float breathe = 1.0 + 0.1 * sin(iTime * uBreatheFreq + uRandomSeed.x);
        vec2 v = p * 1.8 * breathe; 
        
        float i = 0.0;
        float f = 0.0;
        vec4 color = vec4(0.0);

        for(int k=0; k<5; k++) {
            i += 1.0;
            // --- 3. 随机流动速度与方向 ---
            float flowOffset = iTime * uFlowSpeed + sin(iTime * 0.4 + i + uRandomSeed.y);
            
            for(int j=0; j<4; j++) {
                f += 1.0;
                // 利用随机种子改变波纹产生的偏向
                v += sin(v.yx * f + i + flowOffset + uRandomSeed.x) / f;
            }
            
            // 色彩随时间偏移
            vec4 layerColor = (cos(i + vec4(0.0, 1.2, 2.8, 1.0) + iTime * 0.4) + 1.0) * 0.5;
            color += layerColor / length(v * 1.2);
        }

        float dist = length(p);
        float mask = smoothstep(0.95, 0.2, dist); 
        color = color * 0.22 * mask;
        gl_FragColor = vec4(pow(color.rgb, vec3(0.85)), mask);
    }
</script>

    <script>
        const canvas = document.getElementById('siriCanvas');
        const gl = canvas.getContext('webgl', { alpha: true });

        // 1. 在 JS 中生成随机参数
        const randomConfig = {
            rotDir: Math.random() > 0.5 ? 1.0 : -1.0,
            rotSpeed: Math.random() * 0.6 + 0.2,    // 0.2 - 0.8
            flowSpeed: Math.random() * 1.2 + 0.5,   // 0.5 - 1.7
            breatheFreq: Math.random() * 1.5 + 0.5, // 0.5 - 2.0
            seedX: Math.random() * 10.0,
            seedY: Math.random() * 10.0
        };

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            const size = 64 * dpr;
            if (canvas.width !== size) {
                canvas.width = size;
                canvas.height = size;
                gl.viewport(0, 0, size, size);
            }
        }

        const vsSource = `attribute vec4 position; void main() { gl_Position = position; }`;
        const fsSource = document.getElementById('fragmentShader').textContent;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
        gl.linkProgram(program);

        // Check program link status and log errors if linking fails
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Unable to initialize the shader program:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // 获取 Uniform 地址
        const locations = {
            iTime: gl.getUniformLocation(program, "iTime"),
            iRes: gl.getUniformLocation(program, "iResolution"),
            uRotDir: gl.getUniformLocation(program, "uRotDir"),
            uRotSpeed: gl.getUniformLocation(program, "uRotSpeed"),
            uFlowSpeed: gl.getUniformLocation(program, "uFlowSpeed"),
            uBreatheFreq: gl.getUniformLocation(program, "uBreatheFreq"),
            uRandomSeed: gl.getUniformLocation(program, "uRandomSeed")
        };

        const vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        function render(time) {
            resize();
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            const t = time * 0.002;
            gl.uniform1f(locations.iTime, t);
            gl.uniform2f(locations.iRes, canvas.width, canvas.height);

            // 传递随机参数
            gl.uniform1f(locations.uRotDir, randomConfig.rotDir);
            gl.uniform1f(locations.uRotSpeed, randomConfig.rotSpeed);
            gl.uniform1f(locations.uFlowSpeed, randomConfig.flowSpeed);
            gl.uniform1f(locations.uBreatheFreq, randomConfig.breatheFreq);
            gl.uniform2f(locations.uRandomSeed, randomConfig.seedX, randomConfig.seedY);

            gl.drawArrays(gl.TRIANGLES, 0, 3);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>

</html>
